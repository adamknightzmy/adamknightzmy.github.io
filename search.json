[{"title":"Hello World","path":"/2024/03/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"关于Git","path":"/2024/03/26/关于Git/","content":"关于Git的使用方法 git init 为当前目录本地初始化，本地创建仓库 git init \\&lt;repo-name\\&gt; 在当前目录下初始化、创建仓库 git clone \\&lt;https://xxxx.com.xxx.git\\&gt; 远程克隆仓库 git config --global init.defaultBranch main全局更改默认branch(分支)为main git branch -m main 更改branch(分支)为main git config --global --list 可以查看当前git设置的user.name、user.email git config --global credential.helper store git config user.name 查看git用户名 git config user.email 查看git用户邮箱 git config --global user.name &lt;your_name&gt; 设置全局git用户名 git config --global user.email &lt;your_email&gt; 设置全局git用户邮箱 将文件添加到仓库 git init 创建仓库 git status 查看仓库状态 git add 添加到暂存区 git commit 提交 echo &quot;这是第一个文件&quot; &gt; file1.txt 在当前仓库写入“这是第一个文件”到file1.txt文件，如果没有这个文件则先创建再写入 cat file1.txt 查看file.txt文件 git status 查看仓库状态会看到file1.txt这个文件是红色的，也就是未添加到暂存区，属于已修改，未提交暂存状态 git add file1.txt 将文件添加到暂存区 git status 再次查看仓库状态会看到file1.txt会变成绿色，这说明file1.txt文件已将添加到暂存区。 use &quot;git restore --staged &lt;file&gt;...&quot; to unstage 命令窗口会提示这个命令，意思是我们可以使用git restore --staged &lt;file&gt; 这样的命令来把添加到暂存区的文件再取消暂存。这样再次使用git status查看仓库状态，file1.txt文件又会变成红色。 git add *.txt 可以把所有txt类型的文件都一次添加到暂存区 git add . 可以把当前文件下的所有文件都添加到暂存区，.并表示当前目录 git commit 提交当前暂存区文件，这个命令只会提交暂存区的文件，而不会提交工作区中的其他文件。工作区中未被添加到暂存区的文件是不会提交的 git commit -m &quot;更该说明&quot; 如果不使用-m命令，git commit命令会进入一个交互式界面，默认使用vim编辑提交信息 git log 查看提交记录 git log --oneline 查看简洁的提交记录 git reset用于回退版本，可以回退到之前的某一个提交的状态 git reset的三种模式： 软的：git reset --soft 回退到某一个版本，并且保留工作区和暂存区的所有修改内容 硬的：git reset --hard 回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容 混合的：git reset --mixed 回退到某一个版本，并且只保留工作区的修改内容，丢弃暂存区的修改内容。git默认mixed git reflog 查看操作的历史记录 git diff 查看工作区、暂存区、本地仓库之间的差异 查看不同版本之间的差异 查看不同分支之间的差异 git diff 后什么也不加，默认是工作区和暂存区之间的差异内容 git diff head 比较工作区和版本库之间的差异 git diff --cached 比较暂存区和版本库之间的差异 git diff &lt;版本号&gt; &lt;版本号&gt;比较两个特定版本之间的差异 最常用的：git diff head~ head比较当前版本和上一个版本差异 git diff head^ head 作用同上 git diff head~2 head 作用：比较当前版本与提交之前第2个版本差异 git diff head~3 head 作用：比较当前版本与提交之前第3个版本差异 git diff head~3 head &lt;file_name&gt; 作用：比较当前版本特定文件与提交之前第3个版本特定文件之间的差异 查看两个分支之间的差异，直接加上两个分支名 从版本库中删除文件 windows直接删除 git ls-files 查看git仓库中已经被跟踪的文件，即commit之后的文件内容 rm file;git add file 先从工作区删除文件，然后再暂存删除内容 git rm &lt;file&gt; 把文件从工作区和暂存区同时删除 git rm --cached &lt;file&gt; 删除暂存区中的文件，但保留在当前工作区中 git rm -r * 递归删除某个目录下的所有子目录和文件 删除后不要忘记提交 .gitignore文件ignore——忽略 作用：忽略掉一些不应该被加入到版本库中的文件 应该忽略那些文件： 系统或者软件自动生成的文件 编译产生的中间文件和结果文件 运行时生成的日志文件、缓存文件、临时文件 涉及身份、密码、口令、密钥等敏感信息文件 使用方法： 例如本地仓库中有两个log文件：access.log、other.log 其中access.log存放我们的私密信息，我们不想提交。 使用：echo access.log &gt; .gitignore将access.log添加到.gitignore文件中忽略，这样提交的就只是other.log与.gitignore文件，而.gitignore文件中也只有access.log的文件名，并不包含access.log的信息。相当于一个忽略清单。 想要忽略什么文件，什么类型的文件，只要编辑.gitignore文件就OK，比如忽略所有.log文件，只要在.gitignore文件中添加*.log，这样无论是之前存在的，之后新建的log文件都会被忽略 .gitignore文件生效有一个前提：文件不能是已经被添加到版本库中的文件 git status -s 其中-s是short的缩写，是简略的查看状态 忽略文件夹：在.gitignore文件中添加&lt;file_name&gt;/，这样就将整个文件夹（目录）及文件夹下的内容都忽略了。 .gitignore文件的匹配规则： 从上到下逐行匹配，每一行表示一个忽略模式 Git官网匹配规则： https://git-scm.com/docs/gitignore # 用作注释 …(自个儿查去) 远程操作 git clone &lt;ssh链接&gt; 本地克隆远程仓库 git pull 拉取，本地仓库拉取远程仓库信息 git push 推送，本地仓库推送信息给远程仓库 生成SSH Key：ssh-keygen -t rsa -b 4096 私钥文件：id_rsa 公钥文件：id_rsa.pub 克隆仓库：git clone &lt;repo-address&gt; 推送更新内容：git push &lt;remote&gt;&lt;branch&gt; 拉取更新内容：git pull &lt;remote&gt; 本地已有仓库，如何放入远程仓库？ git remote add &lt;shortname&gt;&lt;url&gt; 通常默认的为：origin git remote add origin git@github.com:knightadam/first-repo.git 也可以指定一个其他的别名 git remote -v 查看当前仓库所对应的远程仓库的别名和地址 git branch -M main 指定分支的名称为main git push -u origin main:main 将本地main分支与远程的origin仓库的main分支关联，如果本地分支与远程分支的名称相同，则可以省略：git push origin main git push -f origin main 强制将本地仓库文件提交远程仓库 git pull &lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt; 此处仓库和分支的名称可以省略，如果省略，默认拉取远程仓库别名为origin的main分支，作用就是将远程仓库的指定分支拉取到本地再进行合并 git fetch 只会获取远程仓库的修改，但是并不会自动合并到本地仓库，而是需要手动合并 总结： 添加远程仓库： git remote add &lt;远程仓库别名&gt;&lt;远程仓库地址&gt; 例：git remote add origin git@github.com:knightadam/first-repo.git git push -u &lt;远程仓库名&gt;&lt;分支名&gt; 即：git push -u origin main 查看远程仓库：git remote -v 拉取远程仓库内容： git pull &lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 相同可省略冒号后面的部分 即：git pull origin main Gitee的使用和GitLab本地化部署 gitee.com 特色：国内平台 gitlab.com 特色：私有化部署"},{"title":"MarkDown语法","path":"/2024/03/26/MarkDown语法/","content":"markdown语法代码块：单行代码： 输入： `Hello` 效果：Hello 多行代码： 输入： `&#96;&#96; System.out(“Hello World”);System.out(“Hello World”);System.out(“Hello World”);System.out(“Hello World”); `&#96;&#96; 效果： 1234System.out(&quot;Hello World&quot;);System.out(&quot;Hello World&quot;);System.out(&quot;Hello World&quot;);System.out(&quot;Hello World&quot;); 无序列表： 输入： + 无序列表 - 无序列表 * 无序列表 + 无序列表 效果： 无序列表 无序列表 无序列表 无序列表 有序列表： 输入： 1.(空格) 有序列表 2.(空格) 有序列表 3.(空格) 有序列表 4.(空格) 有序列表 效果： 有序列表 有序列表 有序列表 有序列表 表格： 输入： |表头|表头|表头| |:—|:—:|—:| # 分别：左对齐、居中、右对齐 |内容|内容|内容| |内容|内容|内容| |内容|内容|内容| 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 内容 内容 内容 超链接： 输入： [百度](www.baidu.com) 效果： 百度 图片： 输入： ![img_name](输入图片路径) 效果： 字体样式： 输入： *斜体* **粗体** ***粗斜体*** ~~删除线~~ 效果： 斜体 粗体 粗斜体 删除线 引用： 输入： &gt; &gt; &gt; 效果： 任务列表（有些软件需要插入，不能直接以md语法显示）： 输入： - [] 代办 - [x] 已办 效果："},{"title":"关于这个Blog","path":"/2024/03/23/关于这个Blog/","content":"关于这个Blog&emsp;&emsp;这个Blog是基于Hexo和Github Pages搭建的，主题是基于butterfly搭建的，说实话，这主题真的复杂，以后可能会更改主题。改成简约的Next主题可能会好些… &emsp;&emsp;博客内容主要是一些技术笔记和心得体会。可以是我的日记，笔记，随笔…反正想到什么写什么，想不起来可能就搁置了。"}]